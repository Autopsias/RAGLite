[pytest]
# Test discovery paths
# NOTE: All tests consolidated in tests/ directory (2025-10-28)
# Previously had split between tests/ and raglite/tests/ - now unified
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Performance & Execution Options
# NOTE: Optimized parallel execution strategy:
#   - FAST: Unit tests in parallel (10 workers max), integration grouped (single worker)
#   - FALLBACK: Sequential if parallelization issues occur
#   - OPTIMIZATION: Test ordering (fast first), smart skipping of redundant tests
#
# NOTE: Coverage is NOT in addopts to fix VSCode Test Explorer compatibility
# Add --cov=raglite manually or use Makefile commands for coverage reports
# NOTE: Three test profiles:
#   - SMOKE (CLI): pytest -m smoke (~30s) - Critical path only
#   - FAST (Default): pytest tests/ (~5-10 minutes) - Unit + integration reads
#   - FULL (CI): TEST_USE_FULL_PDF=true pytest tests/ (~30-40 minutes)
#
# OPTIMIZATION STRATEGY (reduces 2300s → 300-600s):
# 1. Unit tests: Maximum parallelism (auto workers)
# 2. Integration tests: Single xdist worker (avoid Mistral rate limiting)
# 3. Test ordering: Fast tests first (quick feedback on failures)
# 4. Timeout: Conservative per-function (900s total allows 150s+ for ingestion)
# 5. Markers: Skip redundant tests (-m "not slow" by default)
addopts =
    -v
    --tb=line
    --strict-markers
    --strict-config
    -ra
    --timeout=900
    --durations=5
    --durations-min=2.0
    # LOCAL MODE (default): Fast tests only - excludes slow/redundant tests
    -m "not slow"
    # OPTIMIZED parallel execution:
    # NOTE: Worker count (-n) is specified per job type in CI and local commands:
    # - Unit tests: -n 4 (balanced parallelism, avoids MacBook Pro freeze)
    # - Integration tests: -n 1 (session fixture + shared Qdrant collection)
    # - E2E tests: -n 0 (sequential, full isolation)
    # Load distribution: --dist loadfile (group tests by file for better worker utilization)
    --dist loadfile

# TWO TEST MODES:
#
# 1. LOCAL (VS Code, default):
#    pytest tests/
#    → Uses 10-page PDF (10-15s ingestion)
#    → Skips @pytest.mark.slow tests
#    → Target: 5-8 minutes total
#
# 2. CI (comprehensive):
#    TEST_USE_FULL_PDF=true pytest tests/ -m ""
#    → Uses 160-page PDF (150s ingestion)
#    → Runs ALL tests including slow ones
#    → Target: 30-50 minutes total

# For sequential execution (debugging): pytest -n 0
# For custom worker count: pytest -n 4
# To disable retries (debugging): pytest --reruns 0

# Async mode
asyncio_mode = auto

# Warning filters
# Suppress third-party deprecation warnings that we cannot fix
# Keep warnings from our own code (raglite.*) visible for debugging
filterwarnings =
    # Suppress EasyOCR (Docling dependency) Pillow deprecation warnings
    # These will be fixed by EasyOCR maintainers before Pillow 13 (2026-10-15)
    ignore::DeprecationWarning:easyocr.*
    # Keep all warnings from raglite code visible
    default::DeprecationWarning:raglite.*
    default::PendingDeprecationWarning:raglite.*
    default::FutureWarning:raglite.*

# Timeout configuration
# Only apply timeout to test functions, NOT to fixtures (session-scoped ingestion takes 16-18 min)
timeout_func_only = true

# Test markers for selective execution
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests (require Qdrant)
    unit: marks tests as unit tests (no external dependencies)
    e2e: marks tests as end-to-end tests
    smoke: marks tests as smoke tests (ultra-fast critical path validation <30s)
    p0: marks tests as priority 0 (critical - must pass)
    p1: marks tests as priority 1 (high priority)
    p2: marks tests as priority 2 (medium priority)
    preserve_collection: skip Qdrant isolation cleanup for this test (optimization for read-only tests)
    manages_collection_state: test calls ingest_pdf(clear_collection=True) - skip re-ingest cleanup (optimization)
    reruns: marks tests for retry on flaky integration tests (requires pytest-rerunfailures)
    reruns_delay: delay in seconds between reruns (requires pytest-rerunfailures)

# Test suite profiles for different workflows:
#
# SMOKE TESTS (ultra-fast <30s):
#   pytest -m smoke
#   → Critical path validation only
#   → Run on every save/commit
#
# UNIT TESTS (fast <2 min):
#   pytest tests/unit
#   → Fast feedback loop
#   → Run before pushing
#
# INTEGRATION TESTS (moderate 5-10 min):
#   pytest tests/integration -m "not slow"
#   → Real API validation
#   → Run before PR
#
# FULL SUITE (comprehensive 15-20 min):
#   pytest tests/
#   → Complete validation
#   → Run in CI/CD

# Performance optimizations
# Cache test results and only re-run changed tests (use --cache-clear to reset)
cache_dir = .pytest_cache

# xdist configuration for parallel execution
# LoadFileScheduling is enabled via --dist loadfile in addopts above
